using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

/// <summary>
/// Loads a fixed-size grid maze from a JSON preset file.
/// - A Python script generates maze_presets.json.
/// - This component loads one preset (random or fixed index),
///   reconstructs map/openRight/openUp/solutionPath,
///   and builds MazeCell objects (with pooling).
/// </summary>
public class MazeGenerator : MonoBehaviour
{
    public static MazeGenerator Instance { get; private set; }

    private void Awake()
    {
        // 이미 인스턴스가 존재하는데 새로 생기려 하면 파괴
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
    }

    [Header("Preset Selection")]
    [Tooltip("If true, pick a random preset index each time. If false, use fixedPresetIndex.")]
    public bool useRandomPreset = false;

    [Tooltip("Used only when useRandomPreset=false. Range 0 ~ (presetCount-1).")]
    public int fixedPresetIndex = 0;

    [Header("Cell Prefab Generation")]
    [Tooltip("Prefab for a single maze cell (contains floor + optional right/up walls).")]
    public MazeCell cellPrefab;

    [Tooltip("Parent transform for instantiated cells. If null, uses this transform.")]
    public Transform cellRoot;

    [Tooltip("World spacing per cell.")]
    public float cellSize = 0.5f;

    [Header("Border Wall Generation")]
    [Tooltip("Single wall prefab. Rotation (0,0,0): horizontal (bottom). Rotation (0,90,0): vertical (left).")]
    public GameObject borderWallPrefab;


    [Header("Branch Resource")]
    [Tooltip("각 branch 끝칸에 두는 리소스 프리팹")]
    public GameObject resource;            // 유저가 인스펙터에서 넣을 프리팹
    [Tooltip("branch 리소스 풀 크기 (기본 7개)")]
    public int resourcePoolSize = 7;

    // branchEnds 좌표 & 리소스 풀
    [HideInInspector] public List<Vector2Int> branchEnds = new List<Vector2Int>();
    List<GameObject> resourcePool = new List<GameObject>();


    // Pool for border walls (left and bottom only)
    List<GameObject> borderWallPool = new List<GameObject>();
    int borderWallCursor = 0;


    public GameObject startPoint;
    public GameObject endPoint;
    public float maxGravity;

    [HideInInspector]
    public MazeCell[,] cellMap;

    // Pooling
    List<MazeCell> cellPool = new List<MazeCell>();
    int poolCursor = 0;

    [Header("JSON Presets")]
    [Tooltip("maze_presets.json generated by Python.")]
    public TextAsset jsonPresetFile;




    private MazePresetJsonRoot jsonPresetCache;

    // Grid info (overwritten by JSON)
    int width;
    int height;

    // Start/Goal (overwritten by JSON)
    Vector2Int start;
    Vector2Int goal;

    // 0 = wall, 1 = path
    [HideInInspector] public int[,] map;

    // Solution path (debug/visualization)
    [HideInInspector] public List<Vector2Int> solutionPath = new List<Vector2Int>();

    // 각 칸에 대응하는 accel 벡터
    Vector3[,] cellAccels;

    // Open edges
    bool[,] openRight;   // size: [width-1, height]
    bool[,] openUp;      // size: [width, height-1]

    void Start()
    {
        Generate();
    }

    void Update()
    {
        // Reload maze when pressing Space
        if (Keyboard.current != null && Keyboard.current.spaceKey.wasPressedThisFrame)
        {
            Generate();
        }
    }

    /// <summary>
    /// Load one preset (random or fixed index).
    /// </summary>
    public void Generate()
    {
        EnsureJsonPresetsLoaded();

        if (jsonPresetCache != null && jsonPresetCache.presets != null && jsonPresetCache.presets.Length > 0)
        {
            int count = jsonPresetCache.presets.Length;
            int idx = useRandomPreset
                ? UnityEngine.Random.Range(0, count)
                : Mathf.Clamp(fixedPresetIndex, 0, count - 1);

            LoadFromJsonPreset(jsonPresetCache.presets[idx]);
            Debug.Log("MazeGenerator: Loaded preset index " + idx
                      + " (useRandomPreset=" + useRandomPreset + ")");
        }
        else
        {
            Debug.LogError("No JSON presets available. Please assign a valid jsonPresetFile.");
        }
    }


    // ---------------------------------------------------------
    // Helpers
    // ---------------------------------------------------------
    bool InBounds(int x, int y)
    {
        return (x >= 0 && x < width && y >= 0 && y < height);
    }

    bool InBounds(Vector2Int p)
    {
        return InBounds(p.x, p.y);
    }

    // ---------------------------------------------------------
    // JSON Load
    // ---------------------------------------------------------
    void EnsureJsonPresetsLoaded()
    {
        if (jsonPresetCache != null) return;
        if (jsonPresetFile == null)
        {
            Debug.LogWarning("jsonPresetFile is not assigned.");
            return;
        }

        jsonPresetCache = JsonUtility.FromJson<MazePresetJsonRoot>(jsonPresetFile.text);
        if (jsonPresetCache == null || jsonPresetCache.presets == null || jsonPresetCache.presets.Length == 0)
        {
            Debug.LogError("Failed to parse JSON presets or no presets found.");
        }
    }

    void LoadFromJsonPreset(MazePresetJson preset)
    {
        if (preset == null)
        {
            Debug.LogError("JSON preset is null");
            return;
        }

        // Grid size
        width = preset.width;
        height = preset.height;

        // Start/Goal
        if (preset.start == null || preset.start.Length < 2 ||
            preset.goal == null || preset.goal.Length < 2)
        {
            Debug.LogError("JSON preset start/goal invalid");
            return;
        }

        start = new Vector2Int(preset.start[0], preset.start[1]);
        goal = new Vector2Int(preset.goal[0], preset.goal[1]);

        // Allocate arrays
        map = new int[width, height];
        openRight = new bool[width - 1, height];
        openUp = new bool[width, height - 1];

        // 1) map
        if (preset.map == null || preset.map.Length != width * height)
        {
            Debug.LogError("JSON preset map size mismatch: expected "
                           + (width * height) + ", got "
                           + (preset.map == null ? -1 : preset.map.Length));
        }
        else
        {
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    int idx = y * width + x;
                    map[x, y] = preset.map[idx];
                }
            }
        }

        // 2) openRight
        if (preset.openRight != null && preset.openRight.Length == (width - 1) * height)
        {
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width - 1; x++)
                {
                    int idx = y * (width - 1) + x;
                    openRight[x, y] = preset.openRight[idx];
                }
            }
        }

        // 3) openUp
        if (preset.openUp != null && preset.openUp.Length == width * (height - 1))
        {
            for (int y = 0; y < height - 1; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    int idx = y * width + x;
                    openUp[x, y] = preset.openUp[idx];
                }
            }
        }

        // 4) solutionPath
        solutionPath = new List<Vector2Int>();
        if (preset.solutionPath != null && preset.solutionPath.Length > 0)
        {
            foreach (var arr in preset.solutionPath)
            {
                solutionPath.Add(new Vector2Int(arr.x, arr.y));
                //Debug.Log(arr.x.ToString() + ", " + arr.y.ToString());
            }
        }



        // 5) force, torque (모든 셀용)
        cellAccels = new Vector3[width, height];

        if (preset.cellForces != null && preset.cellForces.Length == width * height)
        {
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    int idx = y * width + x;     // Python과 동일한 인덱싱

                    var f = preset.cellForces[idx];

                    // Python (gx, gy, torque) → Unity (x:gx, y:torque, z:gy)
                    Vector3 accel = new Vector3(f.gx, f.torque, f.gy);
                    cellAccels[x, y] = accel;
                }
            }
        }
        else
        {
            // 길이가 안 맞거나 없으면 전부 0으로 초기화 (이미 new에서 0으로 채워짐)
            for (int y = 0; y < height; y++)
                for (int x = 0; x < width; x++)
                    cellAccels[x, y] = Vector3.zero;
        }



        // 5) branchEnds
        branchEnds = new List<Vector2Int>();
        if (preset.branchEnds != null && preset.branchEnds.Length > 0)
        {
            foreach (var arr in preset.branchEnds)
            {
                branchEnds.Add(new Vector2Int(arr.x, arr.y));
            }
        }

        Debug.Log("Loaded maze from JSON preset '" + preset.name);

        // Build actual MazeCell objects
        BuildCellsFromData();
    }


    // ---------------------------------------------------------
    // Cell Pooling + Building
    // ---------------------------------------------------------
    void ClearOldCells()
    {
        // Reset object references
        cellMap = null;

        // Disable all pooled cells for reuse
        foreach (var cell in cellPool)
        {
            if (cell != null)
            {
                cell.gameObject.SetActive(false);
                cell.SetHighlight(Color.white);
            }
        }

        poolCursor = 0;

        // disable all pooled border walls
        foreach (var wall in borderWallPool)
        {
            if (wall != null)
                wall.SetActive(false);
        }
        borderWallCursor = 0;


        // branch 리소스도 전부 비활성화
        foreach (var obj in resourcePool)
        {
            if (obj != null)
                obj.SetActive(false);
        }
    }

    MazeCell GetCellFromPool(Transform parent)
    {
        // Reuse existing
        if (poolCursor < cellPool.Count)
        {
            MazeCell reused = cellPool[poolCursor];
            poolCursor++;

            if (reused == null)
            {
                // Safety fallback
                reused = Instantiate(cellPrefab, parent);
                cellPool[poolCursor - 1] = reused;
            }

            reused.gameObject.SetActive(true);
            reused.transform.SetParent(parent, false);
            return reused;
        }
        else
        {
            // Create new
            MazeCell created = Instantiate(cellPrefab, parent);
            cellPool.Add(created);
            poolCursor++;
            return created;
        }
    }

    GameObject GetBorderWallFromPool(Transform parent)
    {
        // reuse existing
        if (borderWallCursor < borderWallPool.Count)
        {
            GameObject reused = borderWallPool[borderWallCursor];
            borderWallCursor++;

            if (reused == null)
            {
                reused = Instantiate(borderWallPrefab, parent);
                borderWallPool[borderWallCursor - 1] = reused;
            }

            reused.SetActive(true);
            reused.transform.SetParent(parent, false);
            return reused;
        }
        else
        {
            // create new
            GameObject created = Instantiate(borderWallPrefab, parent);
            borderWallPool.Add(created);
            borderWallCursor++;
            return created;
        }
    }


    void BuildCellsFromData()
    {
        ClearOldCells();
        
        Vector3 gridOffset = Vector3.zero;

        // After width/height are known:
        gridOffset = new Vector3(-10 * cellSize, 0f, -10 * cellSize);


        if (cellPrefab == null)
        {
            Debug.LogWarning("MazeGenerator.BuildCellsFromData: cellPrefab is not assigned.");
            return;
        }
        if (map == null)
        {
            Debug.LogWarning("MazeGenerator.BuildCellsFromData: map is null.");
            return;
        }

        Transform parent = cellRoot != null ? cellRoot : this.transform;
        cellMap = new MazeCell[width, height];

        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                MazeCell cell = GetCellFromPool(parent);
                cell.cellSize = cellSize;

                bool isPath = (map[x, y] == 1);
                bool reachableHere = isPath;

                // ---------- Right wall ----------
                bool hasRightWall = false;

                if (x < width - 1)
                {
                    // interior edge: use openRight
                    bool reachableRight = (map[x + 1, y] == 1);
                    if (!openRight[x, y] && (reachableHere || reachableRight))
                        hasRightWall = true;
                }
                else
                {
                    hasRightWall = (map[x, y] == 1);
                }

                // ---------- Up wall ----------
                bool hasUpWall = false;

                if (y < height - 1)
                {
                    // interior edge: use openUp
                    bool reachableUp = (map[x, y + 1] == 1);
                    if (!openUp[x, y] && (reachableHere || reachableUp))
                        hasUpWall = true;
                }
                else
                {
                    hasUpWall = (map[x, y] == 1);
                }

                cell.Setup(new Vector2Int(x, y), isPath, hasRightWall, hasUpWall, gridOffset, maxGravity);
                cellMap[x, y] = cell;
            }
        }

        BuildBorderWalls();

        Vector2Int startCoordinate = solutionPath[0];
        startPoint.transform.position = cellMap[startCoordinate.x, startCoordinate.y].gameObject.transform.position;
        Vector2Int endCoordinate = solutionPath[solutionPath.Count - 1];
        endPoint.transform.position = cellMap[endCoordinate.x, endCoordinate.y].gameObject.transform.position;


        // 모든 셀(x,y)에 대해 accel 채우기
        if (cellAccels != null)
        {
            for (int x = 0; x < width; x++)
            {
                for (int y = 0; y < height; y++)
                {
                    MazeCell cell = cellMap[x, y];
                    if (cell == null) continue;

                    // 벽 셀은 굳이 안 넣어도 되면 스킵
                    if (map[x, y] == 0) continue;

                    AccelBehave ab = cell.GetComponentInChildren<AccelBehave>();
                    if (ab == null) continue;

                    Vector3 baseAccel = cellAccels[x, y];

                    // 기존처럼 스케일 조정 유지 (원하면 값 바꿔도 됨)
                    ab.accel = new Vector3(
                        baseAccel.x * 3f,
                        baseAccel.y,
                        baseAccel.z * 3f
                    );
                }
            }
        }



        // branch 리소스 풀 초기화 & 위치 재배치
        if (resource != null && branchEnds != null && branchEnds.Count > 0)
        {
            InitResourcePool(parent);
        }



        int activeCount = Mathf.Min(branchEnds.Count, resourcePool.Count);

        // 필요한 개수만큼만 활성화 + 위치 설정
        for (int i = 0; i < activeCount; i++)
        {
            Vector2Int p = branchEnds[i];
            if (!InBounds(p)) continue;

            MazeCell cell = cellMap[p.x, p.y];
            if (cell == null) continue;

            GameObject obj = resourcePool[i];
            if (obj == null) continue;

            obj.transform.position = cell.transform.position + Vector3.up * 5f; // 셀 중앙
            obj.SetActive(true);
        }

        // 남는 풀은 비활성화
        for (int i = activeCount; i < resourcePool.Count; i++)
        {
            if (resourcePool[i] != null)
                resourcePool[i].SetActive(false);
        }
    }

    void InitResourcePool(Transform parent)
    {
        if (resource == null) return;

        // 필요한 개수만큼 미리 생성 (예: 7개)
        while (resourcePool.Count < resourcePoolSize)
        {
            GameObject obj = Instantiate(resource, parent);
            obj.SetActive(false);
            resourcePool.Add(obj);
        }

        // 부모는 항상 최신 parent로 맞춰줌
        foreach (var obj in resourcePool)
        {
            if (obj != null)
                obj.transform.SetParent(parent, false);
        }
    }


    void BuildBorderWalls()
    {
        if (borderWallPrefab == null)
        {
            // Optional: you can warn once if needed
            return;
        }

        Transform parent = cellRoot != null ? cellRoot : this.transform;

        // Left border (vertical walls)
        // Position: x = -0.5 * cellSize, z = y * cellSize
        // Rotation: (0,90,0)
        for (int y = 0; y < height; y++)
        {
            GameObject wall = GetBorderWallFromPool(parent);
            wall.transform.localPosition = new Vector3(-width/2f * cellSize, 0f, (y - (height-1) / 2f) * cellSize);
            wall.transform.localRotation = Quaternion.Euler(0f, 90f, 0f);
        }

        // Bottom border (horizontal walls)
        // Position: x = x * cellSize, z = -0.5 * cellSize
        // Rotation: identity (0,0,0)
        for (int x = 0; x < width; x++)
        {
            GameObject wall = GetBorderWallFromPool(parent);
            wall.transform.localPosition = new Vector3((x - (width-1) / 2f) * cellSize, 0f,- height / 2f * cellSize);
            wall.transform.localRotation = Quaternion.identity;
        }
    }




    bool AreCellsConnected(Vector2Int a, Vector2Int b)
    {
        if (!InBounds(a) || !InBounds(b)) return false;
        if (map[a.x, a.y] == 0 || map[b.x, b.y] == 0) return false;

        // vertical
        if (a.x == b.x)
        {
            int y0 = Mathf.Min(a.y, b.y);
            if (y0 < 0 || y0 >= height - 1) return false;
            return openUp[a.x, y0];
        }
        // horizontal
        else if (a.y == b.y)
        {
            int x0 = Mathf.Min(a.x, b.x);
            if (x0 < 0 || x0 >= width - 1) return false;
            return openRight[x0, a.y];
        }

        return false;
    }
}

// ============================================================
// JSON structs
// ============================================================

[System.Serializable]
public class MazePresetJsonRoot
{
    public MazePresetJson[] presets;
}

[System.Serializable]
public class Int2
{
    public int x;
    public int y;
}

[System.Serializable]
public class ForceStep
{
    public float gx;      // Unity에서 accel.x 로 쓸 값
    public float gy;      // Unity에서 accel.z 로 쓸 값
    public float torque;  // Unity에서 accel.y 로 쓸 값
}

[System.Serializable]
public class MazePresetJson
{
    public string name;
    public int width;
    public int height;
    public int[] start;      // [x, y]
    public int[] goal;       // [x, y]
    public int[] map;        // length = width * height
    public bool[] openRight; // length = (width - 1) * height
    public bool[] openUp;    // length = width * (height - 1)

    // Optional solution path: [[x,y], [x,y], ...]
    public Int2[] solutionPath;
    public Int2[] branchEnds;


    // Python에서 "solutionForces": [{"gx":..,"gy":..,"torque":..}, ...]
    public ForceStep[] cellForces;
}
